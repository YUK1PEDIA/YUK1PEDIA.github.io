<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/learning-notes" title="Learning Notes">
                    <span>Learning Notes</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/algorithm" title="Algorithm">
                    <span>Algorithm</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式锁
    </h2>
  </header>
  <div class="entry-content">
    <p>基本原理和实现方式 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行。 那么分布式锁他应该满足的条件呢？ 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行 高可用：程序不易崩溃，时时刻刻都保证较高的可用性 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能 安全性：安全也是程序中必不可少的一环 常见的分布式锁有三种： Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见 Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁 Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，zookeeper中实现分布式锁主要依赖于它的临时节点（ephemeral node）和顺序节点（sequential node）特性。 Redis 分布式锁的实现核心思路 实现分布式锁时需要实现的两个基本方法：
获取锁： 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回 true，失败返回 false 释放锁： 手动释放 超时释放：获取锁时添加一个超时时间 实现核心思路：
我们利用 redis 的 setnx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个 key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可。
实现基于 redis 的分布式锁 分布式锁的基本接口
/** * 分布式锁 */ public interface ILock { /** * 尝试获取锁 * @param timeoutSec * @return */ boolean tryLock(long timeoutSec); /** * 释放锁 */ void unlock(); } 简单分布式锁的实现
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分布式锁" href="http://localhost:1313/posts/learning-notes/2024-11-9-distributed-lock/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分治——归并排序与二分查找
    </h2>
  </header>
  <div class="entry-content">
    <p>交易逆序对的总数 在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。
示例 1:
输入：record = [9, 7, 5, 4, 6]输出：8解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。 限制：
0 &lt;= record.length &lt;= 50000 Code
class Solution { public: int mergeSort(vector&lt;int&gt;&amp; record, vector&lt;int&gt;&amp; tmp, int l, int r) { if (l &gt;= r) return 0; int mid = (l &#43; r) / 2; int inv_cnt = mergeSort(record, tmp, l, mid) &#43; mergeSort(record, tmp, mid &#43; 1, r); int i = l, j = mid &#43; 1, pos = l; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (record[i] &lt;= record[j]) { tmp[pos] = record[i]; &#43;&#43;i; inv_cnt &#43;= (j - (mid &#43; 1)); } else { tmp[pos] = record[j]; &#43;&#43;j; } &#43;&#43;pos; } for (int k = i; k &lt;= mid; &#43;&#43;k) { // 右边已经没有比左边当前数更大的了，直接加上 (j - (mid &#43; 1)) tmp[pos&#43;&#43;] = record[k]; inv_cnt &#43;= (j - (mid &#43; 1)); } for (int k = j; k &lt;= r; &#43;&#43;k) { tmp[pos&#43;&#43;] = record[k]; } copy(tmp.begin() &#43; l, tmp.begin() &#43; r &#43; 1, record.begin() &#43; l); return inv_cnt; } int reversePairs(vector&lt;int&gt;&amp; record) { int n = record.size(); vector&lt;int&gt; tmp(n); return mergeSort(record, tmp, 0, n - 1); } }; 二分查找（闭区间写法） int lower_bound(vector&lt;int&gt; &amp;nums, int target) { int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right] while (left &lt;= right) { // 区间不为空 // 循环不变量： // nums[left-1] &lt; target // nums[right&#43;1] &gt;= target // mid 也可以写成：int mid = ((right - left) &gt;&gt; 1) &#43; left; int mid = left &#43; (right - left) / 2; if (nums[mid] &lt; target) { left = mid &#43; 1; // 范围缩小到 [mid&#43;1, right] } else { right = mid - 1; // 范围缩小到 [left, mid-1] } } return left; } 如果要查找的数字不在数组中，上述写法会返回该数组中第一个大于 target 的数的下标。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分治——归并排序与二分查找" href="http://localhost:1313/posts/learning-notes/2024-9-20-divide_and_conquermerge_sorting_and_binary_search/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">前后端跨域与 cookie
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 实习过程中，在某个晚上搭建 apiserver 后端和 webfe 前端时，启动前后端项目后在浏览器访问服务器的域名，出现了返回的状态码为 200，但是前端却拿不到后端数据，即跨域问题。寻求 mt 的帮助后解决了这个问题，收获不小，记录一下
前后端跨域问题 解决跨域？CORS？ cookie 与父子域名</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 前后端跨域与 cookie" href="http://localhost:1313/posts/learning-notes/2025-5-27-cookie/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">前缀和与差分数组
    </h2>
  </header>
  <div class="entry-content">
    <p>前缀和 区域和检索 - 数组不可变
给定一个整数数组 nums，处理以下类型的多个查询:
计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right 实现 NumArray 类：
NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] &#43; nums[left &#43; 1] &#43; ... &#43; nums[right] ) 示例 1：
输入：[&#34;NumArray&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) &#43; 0 &#43; 3)numArray.sumRange(2, 5); // return -1 (3 &#43; (-5) &#43; 2 &#43; (-1)) numArray.sumRange(0, 5); // return -3 ((-2) &#43; 0 &#43; 3 &#43; (-5) &#43; 2 &#43; (-1)) 提示：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 前缀和与差分数组" href="http://localhost:1313/posts/learning-notes/2024-9-13-prefix_sum/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">动态规划-买卖股票问题
    </h2>
  </header>
  <div class="entry-content">
    <p>买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
1 &lt;= prices.length &lt;= 10^5 0 &lt;= prices[i] &lt;= 10^4 思路 两个思路，可以用 dp 也可以用贪心。
dp 做法 定义状态： dp[i][0] 表示第 i 天持有股票的最大利润，dp[i][1] 表示第 i 天不持有股票的最大利润（注意此处持有表示拥有股票，并不一定指当天买入股票） 状态转移 如果当天持有股票，就有两种情况： 前一天就持有了股票，直接由前一天转移过来：dp[i][0] = dp[i-1][0] 前一天并不持有股票，我们需要在当天购买股票：dp[i][0] = -prices[i] （因为只能买卖一次股票，买入股票就一定是 -prices[i] 的利润） 在以上两种情况取最大值即可： dp[i][0] = max(dp[i-1][0], -prices[i]); 如果当天不持有股票，也有两种情况： 前一天就不持有股票：dp[i][1] = dp[i-1][1] 前一天持有股票，这一天卖出：dp[i][1] = dp[i-1][0] &#43; prices[i] 两种情况取最大：dp[i][1] = max(dp[i-1][1], dp[i-1][0]&#43;prices[i]); 边界定义 初始化第 0 天即可 代码如下：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 动态规划-买卖股票问题" href="http://localhost:1313/posts/learning-notes/2024-8-9-stock_trading_problem/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">单调栈
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是单调栈？ 单调栈是一种特殊的栈，在栈的「先进后出」规则基础上，要求「从 栈顶 到 栈底 的元素是单调递增（或者单调递减）」。其中满足从栈顶到栈底的元素是单调递增的栈，叫做「单调递增栈」。满足从栈顶到栈底的元素是单调递减的栈，叫做「单调递减栈」。
单调栈的 push 和 pop 比如我们现在有一组数：[10, 3, 7, 4, 12] ，如何将这组数放到一个单调递增栈中？
我们从左到右遍历数组，根据以下条件判断进行何种操作：
如果栈空或当前遍历到的元素 cur 小于栈顶元素，则入栈； 如果栈非空并且当前遍历到的元素 cur 大于栈顶元素，则将栈中所有比 cur 小的元素出栈，再将 cur 入栈。 对于上述数组，通过单调栈有如下操作：
对于 10 ，当前栈空，直接入栈，此时栈顶到栈底：[10]； 对于 3 ，当前栈非空，且当前元素小于栈顶元素，直接入栈，此时栈顶到栈底：[3, 10]； 对于 7 ，当前栈非空，且当前元素大于栈顶元素，先将栈顶元素 3 出栈，再将 7 入栈，此时栈顶到栈底：[7, 10]； 对于 4 ，当前栈非空，且当前元素小于栈顶元素，直接入栈，此时栈顶到栈底：[4, 7, 10]； 对于 12 ，当前栈非空，且当前元素大于栈顶元素，先将 4、7、10 出栈，再将 12 入栈，此时栈顶到栈底：[12]； 单调栈能解决什么问题？ 当我们遇到：需要在 O(n) 的时间复杂度内求出数组中各个元素右侧或左侧第一个更大或更小的元素及其下标，然后一并得到其他信息时，均可以尝试单调栈的做法
例题 87.每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 单调栈" href="http://localhost:1313/posts/learning-notes/2024-8-9-monotonic_stack/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图论
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 整理自：https://algo.itcharge.cn/和代码随想录：https://www.programmercarl.com/qita/tulunfabu.html
1.图的基础知识 (1).图的定义 图（Graph）：由顶点的非空有限集合 V （由 n&gt;0 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)。
顶点（Vertex）：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。 边（Edge）：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=&lt;u,v&gt;，表示从 u 到 v 的一条边，其中 u 称为起始点，v 称为终止点。 子图（Sub Graph）：对于图 G*=(V,E) 与 G*′=(V′,E′)，如果存在 V*′⊆V，E′⊆E，则称图 ′G′ 是图 G* 的一个子图。在下面的示意图中我们给出了一个图 G 及其一个子图 G。特别的，根据定义，G 也是其自身的子图。 (2).图的分类 2.1无向图和有向图 按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。
无向图（Undirected Graph）：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。 有向图（Directed Graph）：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。 如果无向图中有 n 个顶点，则无向图中最多有 n×(n−1)/2 条边。而具有 n×(n−1)/2 条边的无向图称为 「完全无向图（Completed Undirected Graph）」。
如果有向图中有 n 个顶点，则有向图中最多有 n×(n−1) 条弧。而具有 n×(n−1) 条弧的有向图称为 「完全有向图（Completed Directed Graph）」。
2.2环形图和无环图 路径：简单来说，如果顶点 vi0 可以通过一系列的顶点和边，到达顶点 vim，则称顶点 vi0 和顶点 vim 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。 环（Circle）：如果一条路径的起始点和终止点相同（即 vi0*==vi*m ），则称这条路径为「回路」或者「环」。 简单路径：顶点序列中顶点不重复出现的路径称为「简单路径」。 而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 图论" href="http://localhost:1313/posts/learning-notes/2024-10-28-graph_theory/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">在MySQL集群中，在从库已经读到了最新值的情况下，主库还有可能读到旧值吗？
    </h2>
  </header>
  <div class="entry-content">
    <p>参考：https://golangguide.top/
对于 MySQL 数据库，为了得到更高的性能，一般会搭建 MySQL 集群实现读写分离，主库用于写操作，从库用于读操作。虽然主库一般用于写，但也是能读的。那么就有这样一个问题：在 MySQL 集群中，在从库已经读到了最新值的情况下，主库还有可能读到旧值吗？
正常的主从更新流程 假设在主库和从库中都有一张 user 表，此时有以下数据：
id name age 1 小王 72 2 小李 60 我们往主库执行写操作时，一般都能理解成单条语句的事务，比如下面两段 SQL 效果相同：
update user set age = 50 where id = 1; begin; update user set age = 50 where id = 1; commit; 如果事务执行成功了，数据会先写入到主库的 binlog 文件中，然后再刷入磁盘。
binlog 文件是 MySQL 的 server 层日志，记录了用户对数据库有哪些变更操作，比如建数据库表、加字段，以及对某些行的增删改等。
如果两个 MySQL 节点配置好了主从关系，那么它们之间会建立一个 TCP 长连接，主要用于传输同步数据。
除此之外，主库还会再创建一个 binlog dump 线程，将 binlog 文件的变更发送给从库。以上，主库的工作就结束了。
当从库通过之前创建的 TCP 长连接收到 binlog 后，会有一个 IO 线程负责把收到的数据写入到 **relay log（中继日志）**中，然后再有一个 SQL 线程来读取 relay log 的内容，接下来对从库执行 SQL 语句操作，完成数据的主从同步。
为什么要先写一遍 relay log 然后再写从库？ relay log 的作用就类似一个中间层，主库是多线程并发写的，从库的 SQL 线程是单线程串行执行的，所以两边的生产和消费速度肯定不同。当主库的 binlog 消息过多时，从库的 relay log 可以起到暂存主库数据的作用，接着从库的 SQL 线程再慢慢消费这些 relay log 数据，这样既不会限制主库发消息的速度，也不会给从库造成过大的压力。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 在MySQL集群中，在从库已经读到了最新值的情况下，主库还有可能读到旧值吗？" href="http://localhost:1313/posts/learning-notes/2025-1-18-in-a-mysql-cluster-is-it-possible-for-the-master-database-to-read-the-old-value-even-if-the-slave-database-has-read-the-latest-value/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">基于Redis的用户短信登陆功能
    </h2>
  </header>
  <div class="entry-content">
    <p>1.发送验证码功能实现 前端会给后端传入 String 和一个 HttpSession ，然后对应的 controller 调用 service 层的 sendCode 方法：
/** * 发送手机验证码 */ @PostMapping(&#34;code&#34;) public Result sendCode(@RequestParam(&#34;phone&#34;) String phone, HttpSession session) { return userService.sendCode(phone, session); } 通过 RandomUtil 实现随机生成验证码并保存到 redis 中。此处的返回验证码仅仅是模拟返回过程，并不是真实返回。
/** * 发送验证码 * @param phone * @param session * @return */ @Override public Result sendCode(String phone, HttpSession session) { // 1.校验手机号 if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合 return Result.fail(&#34;手机号格式错误！&#34;); } // 3.符合，生成验证码 String code = RandomUtil.randomNumbers(6); // 4.保存验证码到 redis stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY &#43; phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES); // 5.返回验证码 log.debug(&#34;发送短信验证码成功，验证码：{}&#34;, code); return Result.ok(); } 2.登录功能实现 前端会给后端传入 LoginFormDTO 和一个 HttpSession ，然后对应的 controller 调用 service 层的 login 方法：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 基于Redis的用户短信登陆功能" href="http://localhost:1313/posts/learning-notes/2024-11-6-redis_login/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">复盘总结
    </h2>
  </header>
  <div class="entry-content">
    <p>[TOC]
OS 进程、线程和协程三者的区别？各自有什么优势？ 进程是操作系统资源调度的基本单位，拥有独立的内存空间和系统资源。每个进程有独立的内存空间，互不干扰，创建和切换进程的开销比较大，进程间通信较复杂 线程是进程内的执行单元，共享进程的内存和资源。创建和切换线程的开销较小，但同步比较复杂 协程是用户态的轻量级线程，由程序员控制调度，无需操作系统介入。创建和切换协程的开销非常小，适合高并发的场景 线程同步方式有哪些？ 互斥锁、读写锁、信号量、自旋锁、临界区 协程调度的底层？ 协程调度主要由用户态控制，底层机制依赖于 协作式多任务 ，即协程主动让出执行权，而不是被强制抢占 协程调度基于以下两个核心机制： 保存和恢复上下文：切换时保存程序计数器、寄存器、栈指针等信息，并恢复下一个协程的上下文 事件循环：协程调度器通常基于事件循环实现，事件循环负责管理协程的状态和调度（FIFO、优先级调度、时间片轮转等） 当前内存不足 500mb，此时申请 500mb 会发生什么？ 可能直接抛出异常，返回内存分配失败 如果系统启用了 交换空间 机制，操作系统会将部分不常用的内存页换出到交换空间，然后尝试分配 500mb 内存 交换空间：当内存不足时，Linux 把某些页的内容转移到硬盘上的一块空间，以释放内存。硬盘上的那块空间叫做交换空间 内存严重不足时，Linux 内核中的 OOM Killer 会终止占用内存最多的进程，然后尝试分配 500mb 内存 Linux 是如何管理内存的？ 虚拟内存机制 主要采用的是 页式内存管理 虚拟地址空间分为 内核空间 和 用户空间 两部分，每个进程有自己的用户空间，包含代码段、数据段、堆、栈等；内核空间被所有进程共享 内存回收机制 页面缓存、交换空间、内存压缩、OOM Killer epoll 介绍一下？ IO 多路复用：用一个线程（或进程）同时管理多个 I/O 操作，而不是为每个 I/O 操作单独开一个线程 将已连接的 Socket 都放到一个 文件描述符集合 中，epoll 使用 红黑树 来跟踪进程所有待检测的文件描述字，select/poll 每次操作都传入整个 Socket 集合给内核，而 epoll 只需要传入一个待检测的 Socket，减少了内核和用户空间大量的数据拷贝 epoll 红黑树中存储键值对（文件描述符以及对应的事件） key：文件描述符（fd） value：监听的事件类型 事件驱动 机制，内核维护了一个链表记录就绪事件，当某个 Socket 有事件发生，通过 回调函数 内核会将其加入到就绪事件列表 就绪链表存放的也是 已就绪的 文件描述符 和 监听的事件类型 epoll 支持两种事件触发模式：边缘触发 和 水平触发 边缘触发：当被监控的 Socket 上有可读事件发生时，服务器端只会从 epoll_wait 中 苏醒一次 ，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完 水平触发：当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束 举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是 边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式 计网 TCP 和 UDP 的区别？
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 复盘总结" href="http://localhost:1313/posts/learning-notes/2025-3-28-review-and-summary/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/posts/page/4/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/posts/page/6/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
