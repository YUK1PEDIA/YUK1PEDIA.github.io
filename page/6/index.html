<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>YUKIPEDIA's blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://yuk1pedia.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yuk1pedia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuk1pedia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuk1pedia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yuk1pedia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yuk1pedia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuk1pedia.github.io/index.xml><link rel=alternate hreflang=en href=https://yuk1pedia.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yuk1pedia.github.io/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="YUKIPEDIA's blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="YUKIPEDIA's blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"YUKIPEDIA's blog","url":"https://yuk1pedia.github.io/","description":"","logo":"https://yuk1pedia.github.io/favicon.ico","sameAs":["https://github.com/YUK1PEDIA"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuk1pedia.github.io/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuk1pedia.github.io/learning-notes title="Learning Notes"><span>Learning Notes</span></a></li><li><a href=https://yuk1pedia.github.io/algorithm title=Algorithm><span>Algorithm</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>大一随笔</h2></header><div class=entry-content><p>前言 我高考录取到的专业并不是计算机而是建筑，因此我的整个大一是在思明校区度过的。可能是从小和电脑打交道比较早（？），也可能是看到将来的就业前（钱）景，进入厦大后萌生出转专业到计算机的想法。我开始写这篇博客的时间是 2024年 7 月 25 日的 23:08，因此本篇记录的快乐大一时光大多基于我对手机上万张照片的回忆~~~
（全都是流水账
第二次抵达厦门 其实我在初三毕业后就来过厦门，也参观过厦大，所以 2022 年那会刚到厦门给我一种熟悉又陌生的感觉
个人（）二维码（bushi
从武汉天河机场出发啦~
那会疫情还没有完全开放，仍然在进行（）检测，在2022 年 9 月 5 日抵达厦门后（9 月 6 日报道），由于忘记了提前进行（）检测，只能在校外酒店额外多待三天orz。。。还好那会建院的辅导员赵妈妈迅速给出了线上报道的解决方案
于是乎我就先在校外闲逛了三天，之后才和舍友在宿舍汇合
到处乱逛ing
进校和舍友汇合~
在厦大的第一顿饭，好像那会正好碰上中秋，食堂有免费的月饼
二次到访芙蓉隧道~
我超，（）！
军训~
军训结束后就开始选课了，拿到了大学的第一张课表，此时我才发现建筑需要美术功底呃啊
喜提新车后沿着环岛路骑了一段，之后就开始上课，步入正常的大学生活啦
在思明校区建院的一年 大一上 开始上课之后了解到了建筑类有自己的个人工位，方便完成设计课和其他课程的作业，也方便和同学聊天吹水打游戏。然后我在整理工位时找到了某个不可名状之物并将其粘贴到了宿舍窗户上
完成设计课的第一次作业orz
hhhhhhhh画图闲下来叠的龙猫
之后有次新生研讨课有问之后就读专业的意向，那会我好像已经确定了要转专业了
学院组织的心理素拓破冰活动，公众号还给了一张特写hhhh
没有任何画画功底的速写与素描（
设计课也开始做模型了，图中的那个黄色胶水挺难闻的。。。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 大一随笔" href=https://yuk1pedia.github.io/posts/learning-notes/2024-7-29-first-year_record/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何爬取厦大智慧教务签到码</h2></header><div class=entry-content><p>前言 本文是作者在学习计算机网络八股文的过程中做的小实践，仅供学习使用，请勿使用此方法逃避考勤。
操作过程 爬取签到码前需要准备什么？ 一台可以联网并且安装有微信的电脑 一个可以抓取网络流量包的软件（我使用的是Proxyman） 抓包过程 使用电脑登陆微信，搜索厦大智慧教务小程序并打开
点击课程签到，进入课程签到界面
然后电脑打开 Proxyman，并打开监听
之后回到小程序，点击“启动签到”，小程序会进入输入签到码并获取定位的界面，此时回到 Proxyman，找到 getXsQdInfo 这个包，打开 Response 的 Body ，找到 "klHm" 这个 key ，它对应的 value 就是签到码</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 如何爬取厦大智慧教务签到码" href=https://yuk1pedia.github.io/posts/learning-notes/2024-7-30-xmu_checkin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>完全背包与多重背包</h2></header><div class=entry-content><p>1.什么是完全背包？ 有 N 件物品和一个最多能背重量为 W 的背包，第 i 件物品的重量是 weight[i] ，得到的价值是 value[i] 。每件物品都有无限个（可以放入背包多次），求解将哪些物品装入背包里价值总和最大，最大价值是多少。
2.和01背包的区别在哪里 01背包和完全背包唯一的不同就是在遍历顺序上，我们先看01背包的核心代码：
for (int i = 0; i &lt; weight.size(); ++i) { // 遍历物品 for (int j = bagWeight; j >= weight[i]; --j) { // 遍历背包容量 dp[j] = max(dp[j], dp[j-weight[i]] + value[i]); } } 可以看出，01背包内嵌的循环是从大到小遍历的，这样能保证每件物品仅被添加一次
而完全背包的物品是可以添加多次的，所以需要从小到大去遍历：
for (int i = 0; i &lt; weight.size(); ++i) { // 遍历物品 for (int j = weight[i]; j &lt;= bagWeight; ++j) { // 遍历背包容量 dp[j] = max(dp[j], dp[j-weight[i]] + value[i]); } } 3.完全背包中的组合数和排列数 对于完全背包问题，有一个很重要的问题：**为什么遍历物品在外层，遍历背包容量在内层？**在01背包问题中，二维数组先遍历物品还是先遍历背包容量是无所谓的（一维数组必须先遍历物品，再遍历容量），可以颠倒。
在纯完全背包问题中，对于一维 dp 数组而言，两个 for 循环的嵌套顺序其实也是无所谓的，因为 dp[j] 是根据下标 j 之前所对应的 dp[j] 计算出来的，只要保证下标 j 之前的 dp[j] 都是经过计算的即可。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 完全背包与多重背包" href=https://yuk1pedia.github.io/posts/learning-notes/2024-7-27-complete_knapsack_problem_and_multiple_knapsack_problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>微服务体系结构、Nacos和熔断器</h2></header><div class=entry-content><p>微服务四大设计原则 独立部署 每个微服务都应该能够独立部署、升级和扩展，而不影响其他微服务的正常运行。独立部署使得微服务架构能够灵活应对变化，无论是业务需求变化、性能优化，还是技术更新，都能以最小的代价进行。
减少系统间的依赖：一个微服务的更新或部署不会影响到其他服务，避免了传统单体应用中常见的“大规模部署”问题。 更高的开发和运维效率：可以根据需求，独立迭代、测试和发布某个微服务。 弹性扩展：某些高负载的微服务可以独立扩展，其他微服务不受影响。 比如，在一个电商系统中，订单服务和支付服务是两个微服务。当订单服务的某个功能需要更新时，可以单独更新订单服务而不影响支付服务的正常运行。
集中配置 微服务架构中，所有微服务的配置应该集中管理。配置管理工具（如 nacos 或 eureka）可以帮助我们集中管理和动态更新多个微服务的配置，而无需分别修改每个微服务的配置文件。如果不进行集中配置，当我们修改某个微服务的配置文件时，就需要对该微服务进行重新打包部署，非常繁琐。
统一管理：避免每个微服务有独立配置文件，造成分散管理的复杂性。 快速更新：可以集中更新所有服务的配置，而无需重新部署每个服务。 灵活性和一致性：不同环境（开发、测试、生产）可以共享配置管理，确保配置的一致性。 客户透明 客户（客户端）与微服务之间的交互应该尽量透明，客户端不应关注微服务的内部实现和部署细节。对于微服务来说，不同微服务之间会存在相互调用，而调用的方式并不会通过微服务所在的服务器 ip 去发送请求，而是通过一个查名服务器来集中管理所有服务器 ip 。这样就能使得不同微服务之间直接通过服务名称进行调用。
简化客户端开发：客户端只需要调用暴露的 API，不关心服务的具体实现或是否有多个服务在背后处理请求。 提升用户体验：即使微服务背后发生了变更，客户端与服务的通信方式保持一致，用户感知不到系统的变动。 更好的扩展性和灵活性：服务可以随着需求变化进行重构或扩展，客户端无需做任何更改。 服务容错 微服务架构应该能够容忍部分服务的故障，避免单个微服务的故障引发整个系统崩溃。通过采取容错策略（如熔断器、重试机制、回退策略等），即使某个服务出现问题，系统的其余部分也能继续正常工作。
增强系统可靠性：服务容错使得系统能够在部分服务失败的情况下继续正常运行，避免级联故障。 提高用户体验：即使某个微服务出现故障，系统仍能返回合适的错误信息或提供降级服务，不至于让用户体验到大规模的中断。 容忍服务的不可预测性：在分布式系统中，网络延迟、服务崩溃等都是常见问题，容错机制有助于减轻这些问题带来的影响。 Nacos Nacos（全称：Dynamic Naming and Configuration Service）是一个开源的 动态服务发现、配置管理 和 服务管理 平台，主要用于分布式系统中微服务架构的服务治理。简单来说，Nacos 解决了微服务架构中服务注册、发现、配置管理等问题。
在一个微服务架构中，服务通常是分布式的，服务的实例可能会动态变化（比如启动、关闭或重启），而每个服务也可能会有不同的配置（如数据库连接、API 配置等）。如何管理这些动态变化的服务和配置，就成了一个挑战。Nacos 就是为了解决这些问题而出现的。
主要功能：
服务注册与发现 微服务架构中，多个微服务需要相互通信。Nacos 提供了服务注册与发现功能，每个微服务启动时会把自己的信息（如 IP、端口等）注册到 Nacos 上，其他微服务可以通过 Nacos 来查找并调用它。 这样，如果某个微服务的实例发生变化（如重新启动或增加新的实例），Nacos 会自动更新，避免了硬编码和手动维护服务地址。 动态配置管理 Nacos 允许集中管理微服务的配置信息（如数据库连接、日志级别等）。你可以将配置文件统一保存在 Nacos 上，微服务启动时从 Nacos 获取配置信息（如果 Nacos 服务器上没有对应的配置信息，则使用本地的配置文件）。 更重要的是，当配置发生变化时（例如修改数据库连接），Nacos 可以实现 热更新，服务无需重启就可以自动加载新的配置，确保服务配置的动态调整。 服务健康检查 Nacos 会定期检查注册到它的服务的健康状态，如果某个微服务宕机或无法访问，Nacos 会自动剔除掉这个服务的注册信息，避免客户端访问失效的服务。 分布式锁 Nacos 支持分布式锁机制，帮助解决微服务间的并发控制问题。 多种数据源支持 Nacos 支持多种配置数据源，包括 数据库、文件、KV 存储等，方便集成和扩展。 Nacos 的数据存储在哪里？ Nacos 默认使用 嵌入式数据库 来存储数据，但在实际生产环境中，存在大规模的并发请求，Nacos 默认的嵌入式数据库没有高可用性保障，因此往往选择将数据存储到 外部数据库（如 MySQL）中。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 微服务体系结构、Nacos和熔断器" href=https://yuk1pedia.github.io/posts/learning-notes/2025-2-11-microservices-architecture-nacos-and-fuses/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>快速幂</h2></header><div class=entry-content><p>算法流程如下
代码实现时，注意 n=−2^31 的情况，取反后 n=2^31 超出 int 最大值。可以转成 64 位 int 解决。
class Solution { public: double myPow(double x, int N) { double ans = 1; long long n = N; if (n &lt; 0) { // x^-n = (1/x)^n n = -n; x = 1 / x; } while (n) { // 从低到高枚举 n 的每个比特位 if (n & 1) { // 当前比特位是 1 ans *= x; // 把 x 乘到 ans 中 } x *= x; // x 自身平方 n >>= 1; // n 右移，继续枚举下一个比特位 } return ans; } };</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 快速幂" href=https://yuk1pedia.github.io/posts/learning-notes/2024-8-19-fast_exponentiation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>数位dp通用模板</h2></header><div class=entry-content><p>数位动态规划（数位dp）主要用于解决“在区间 [l, r] 这个范围内，满足某种约束的数字的数量、总和、平方”这一类问题
前置知识：位运算与集合论 集合可以用二进制表示，二进制从低到高，第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0, 2, 3} 对应的二进制数为 1101 。
设集合对应的二进制数为 x ：
判断元素 d 是否在集合中：x >> d & 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。 把元素 d 添加到集合中：将 x 更新为 x | (1 &lt;&lt; d) 。 下面用一道题来介绍数位 dp 的通用模板
统计特殊整数 如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。
给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。
示例 1：
输入：n = 20 输出：19 解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。 示例 2：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 数位dp通用模板" href=https://yuk1pedia.github.io/posts/learning-notes/2024-9-20-shuwei_dp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>最大子数组和</h2></header><div class=entry-content><p>对于最大子数组和的动态规划问题，一般这样思考：
定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i] = a[i] ，和 i 左边拼起来就是 f[i] = f[i-1] + a[i] ，取最大值就得到了状态转移方程 f[i] = max(f[i-1], 0) + a[i] ，答案为 max(f) 。这种做法也称为 Kadane 算法。
1.最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组
是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [5,4,-1,7,8] 输出：23 提示：
1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 思路 按照前面说的进行状态转移即可
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 最大子数组和" href=https://yuk1pedia.github.io/posts/learning-notes/2024-8-22-maximum_subarray_sum/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>死锁产生的条件？如何诊断死锁？</h2></header><div class=entry-content><p>死锁产生的条件 在操作系统中，死锁只有同时满足以下四个条件才会发生：
互斥条件 持有并等待条件 不可剥夺条件 环路等待条件 在 java 程序中，由于 java 自带线程，因此自己编写的两条线程也可能出现死锁的情况。
具体而言，java 程序里死锁产生的条件是两条线程分别持有两个锁，并且都在尝试获取对方所持有的锁，这样就造成了死锁。
以下面的程序为例：
public class Main { public static void main(String[] args) { Object A = new Object(); Object B = new Object(); Thread t1 = new Thread(() -> { synchronized (A) { System.out.println("lock A"); try { sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized (B) { System.out.println("lock B"); System.out.println("操作..."); } } }, "t1"); Thread t2 = new Thread(() -> { synchronized (B) { System.out.println("lock B"); try { sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized (A) { System.out.println("lock A"); System.out.println("操作..."); } } }, "t2"); t1.start(); t2.start(); } } 线程 t1 和线程 t2 分别获取了锁 A 和锁 B ，并且都在尝试获取对方的锁，因此就出现了死锁：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 死锁产生的条件？如何诊断死锁？" href=https://yuk1pedia.github.io/posts/learning-notes/2025-1-21-what-are-the-conditions-for-deadlocks-to-occur-how-do-i-diagnose-a-deadlock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>泛型与函数式编程</h2></header><div class=entry-content><p>泛型与函数式编程 函数式编程：在Java中，函数式编程是一种编程范式，它把计算视为数学上的函数求值，并且避免了状态和可变数据。这意味着在函数式编程中，函数是“一等公民”，它们可以作为参数传递给其他函数，也可以作为结果从函数中返回。此外，函数式编程鼓励使用不可变对象来减少副作用，从而提高代码的可读性和可维护性。 泛型：泛型是Java语言的一个重要特性，它允许你在定义类、接口和方法时使用类型参数。这样做的好处是可以重用相同的代码来处理不同的数据类型，同时还能获得编译时的类型安全检查，避免运行时出现类型错误。简单来说，泛型就是一种参数化类型的机制，即所操作的数据类型可以被指定为一个参数，这种参数类型可以在使用时确定。 应用 我们以下面的需求为例子：
方法 1： 方法 1 需要将任意 java 对象序列化为 json 并存储在 string 类型的 key 中，还需要设置 TTL 过期时间。显然这个方法并不需要返回值，我们可以复用 StringRedisTemplate 的 set 方法，并结合 JSONUtil 工具包的 toJsonStr 方法实现该功能。
由于需要存储在 string 类型的 key 中，所以需要传入一个 String 类型的变量 key ；由于是任意 java 对象，因此 value 定义成 Object 类型；对于设置 TTL 过期时间，我们可以仿照 Spring 的风格，传入一个 Long 类型的 time 和一个 TimeUnit（时间单位）。
public void set(String key, Object value, Long time, TimeUnit unit) { stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); } 方法 2： 在方法 1 的基础上需要添加一个逻辑过期时间，这里逻辑过期时间的作用是防止 redis 出现缓存击穿的情况，缓存击穿、穿透、雪崩的介绍在：https://yuk1pedia.github.io/2024/11/Cache-penetration,-cache-avalanche,-and-cache-breakdown/
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 泛型与函数式编程" href=https://yuk1pedia.github.io/posts/learning-notes/2024-11-7-generics-and-functional-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>线程崩溃后为什么不会导致 JVM 崩溃？</h2></header><div class=entry-content><p>要弄明白这个问题，我们从以下几点进行分析：
线程崩溃后，进程一定会崩溃吗？ 进程是如何崩溃的？——信号机制简介 为什么在 JVM 中线程崩溃不会导致 JVM 进程崩溃？ 线程崩溃后，进程一定会崩溃吗？ 一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。这主要是因为在进程中，各个线程的地址空间是共享的，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而会影响到其他线程，可能导致一系列严重的后果，于是操作系统干脆让整个进程崩溃。
在一个进程中，所有的线程共享代码段、数据段、地址空间，文件非法访问内存有以下几种情况：
针对只读内存写入数据 #include&lt;stdio.h> #includ&lt;stdlib.h> int main() { char *s = "hello world"; // 向只读内存写入数据，导致崩溃 s[1] = 'H'; } 访问了进程没有权限访问的地址空间（比如内核空间） #include&lt;stdio.h> #includ&lt;stdlib.h> int main() { int *p = (int *)0xC0000fff; // 针对进程的内核空间写入数据，导致崩溃 *p = 10; } 在 32 位虚拟地址空间中，p 指向的是内核空间
访问了不存在的内存 #include&lt;stdio.h> #includ&lt;stdlib.h> int main() { int *a = NULL; *a = 1; } 以上错误都是访问内存时的错误，会统一报 Segment Fault 错误，这些都会导致进程崩溃
进程是如何崩溃的？——信号机制简介 既然线程崩溃后，进程也会崩溃，那进程到底是如何崩溃的呢？其背后的机制是信号。
如果我们想要杀掉一个正在运行的进程，常常会用到 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思，其中 9 就是信号。
在 Linux 中可以通过 kill -l 查看所有可用的信号：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to 线程崩溃后为什么不会导致 JVM 崩溃？" href=https://yuk1pedia.github.io/posts/learning-notes/2025-1-15-why-doesnt-a-thread-crash-cause-the-jvm-to-crash-after-it-crashes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://yuk1pedia.github.io/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://yuk1pedia.github.io/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://yuk1pedia.github.io/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>