<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>YUKIPEDIA's blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://yuk1pedia.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yuk1pedia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuk1pedia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuk1pedia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yuk1pedia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yuk1pedia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuk1pedia.github.io/index.xml><link rel=alternate hreflang=en href=https://yuk1pedia.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yuk1pedia.github.io/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="YUKIPEDIA's blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="YUKIPEDIA's blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"YUKIPEDIA's blog","url":"https://yuk1pedia.github.io/","description":"","logo":"https://yuk1pedia.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuk1pedia.github.io/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuk1pedia.github.io/learning-notes title="Learning Notes"><span>Learning Notes</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JDBC学习笔记</h2></header><div class=entry-content><p>JDBC-API详解 一、DriverManager 1.DriverManager(驱动管理类)作用 (1).注册驱动
(2).获取数据库连接
二、Connection 1.Connection(数据库连接对象)作用 (1).获取执行SQL的对象
(2).管理事务
什么是事务？数据库中的事务是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。
2.具体操作 获取执行SQL对象 (1).普通执行SQL对象
Statement createStatement() (2).预编译SQL的执行SQL对象：防止SQL注入
PreparedStatement prepareStatement(sql) (3).执行存储过程的对象(不常用)
CallableStatement prepareCall(sql) 事务管理 (1).MySQL事务管理
开启事务：BEGIN;/START TRANSACTION;
提交事务：COMMIT;
回滚事务：ROLLBACK;
注：MySQL默认自动提交事务
(2).JDBC事务管理：Connection接口中定义了3个对应的方法
开启事务：setAutoCommit(bollean autoCommit)：true为自动提交事务；false为手动提交事务，即为开启事务
提交事务：commit()
回滚事务：rollback()
三、Statement 1.Statement作用 执行SQL语句 int executeUpdate(sql) 执行DML、DDL语句，返回值：(1).DML语句影响的行数；(2).DDL语句执行后，执行成功也可能返回0
ResultSet executeQuery(sql) 执行DQL语句，返回值：ResultSet结果集对象
四、ResultSet 1.ResultSet(结果集对象)作用 封装了DQL查询语句的结果
ResultSet stmt.executeQuery(sql); 以上语句执行DQL语句，返回一个ResultSet对象
2.获取查询结果 boolean next(); (1).将光标从当前位置向前移动一位；(2).判断当前行是否为有效行
返回值：(1).true：有效行，当前行有数据；(2).false：无效行，当前行无数据
xxx getXxx(参数); 上述语句用于获取数据，其中xxx表示数据类型，如：int getInt(参数)；String getString(参数)
参数：(1).对于int，参数是列的编号（从1开始）；(2).对于String，参数是列的名称
3.使用步骤 (1).游标向下移动一行，并判断该行是否有数据：next()
(2).获取数据：getXxx(参数)
// 循环判断游标是否是最后一行末尾 while (rs.next()) { // 获取数据 rs.getXxx(参数); } 五、PreparedStatement 作用：预编译SQL语句并执行，预防SQL注入问题
什么是SQL注入：SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法
1.获取PreparedStatement对象 // SQL语句中的参数值使用? 占位符替代 String sql = "select * from user where username = ? and password = ?"; // 通过Connection对象获取并传入对应的SQL语句 PreparedStatement pstmt = conn.prepareStatement(sql); 2.设置参数值 PreparedStatement对象：setXxx(参数1，参数2)：给？赋值 (1)Xxx：数据类型；如setInt(参数1,参数2) (2)参数： 参数1：？的位置编号，从1开始 参数2：？的值 3.执行SQL executeUpdate();/executeQuery(); 由于创建PreparedStatement对象时已经传入了SQL语句，所以此处不用再传入SQL语句
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to JDBC学习笔记" href=https://yuk1pedia.github.io/learning-notes/2024-4-6-jdbc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lambda表达式在STL中的应用</h2></header><div class=entry-content><p>C++中的Lambda表达式是一种简洁的方式来定义匿名函数，尤其在需要传递函数作为参数或局部定义函数时非常方便
Lambda表达式的语法格式如下：
[capture](parameters) -> return_type { // function body }; capture：用于捕获外部变量，类似闭包。可以通过值传递或引用传递。 parameters：函数的参数列表（可以为空）。 return_type（可选）：指定返回类型，若省略，编译器会自动推导。 function body：函数体，包含实际执行的代码。 举个简单的例子：
auto add = [](int a, int b) -> int { return a + b; }; 这个Lambda表达式创建了一个匿名函数，它接受两个整数参数a和b，并返回它们的和。
捕获外部变量：在Lambda表达式中可以通过捕获列表来引用函数外部的变量，有三种常见方式：
按值捕获 [x]：捕获外部变量x的值。
按引用捕获 [&amp;x]：捕获外部变量x的引用，可以在Lambda内部修改它。
隐式捕获 [=]（按值捕获所有外部变量）、[&]（按引用捕获所有外部变量）。
示例：
int factor = 10; auto multiply = [factor](int x) { return x * factor; }; // 按值捕获 常见用法
自定义比较器：在排序、优先队列等场合，通常需要根据特定规则对元素进行排序。
std::sort 自定义排序： vector&lt;int> arr = {5, 2, 9, 1}; sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; // 降序排列 }); 优先队列（最大堆或最小堆）： priority_queue&lt;int, vector&lt;int>, decltype([](int a, int b) { return a > b; })> pq; 函数对象作为参数传递：在STL算法函数中，Lambda常被用作传递的回调函数，比如std::for_each, std::count_if等。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to Lambda表达式在STL中的应用" href=https://yuk1pedia.github.io/learning-notes/2024-9-13-lambda/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-二叉树</h2></header><div class=entry-content><p>1.根据前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
示例 1:
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2:
输入: preorder = [-1], inorder = [-1] 输出: [-1] 提示:
1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 思路
前序遍历：按照「根-左子树-右子树」的顺序遍历二叉树。
中序遍历：按照「左子树-根-右子树」的顺序遍历二叉树。
我们来看看示例 1 是怎么生成这棵二叉树的。
递归边界：如果 preorder 的长度是 0，对应着空节点，返回空。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-二叉树" href=https://yuk1pedia.github.io/learning-notes/2024-10-21-binary-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-位运算</h2></header><div class=entry-content><p>1.位1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示：
输入必须是长度为 32 的 二进制串 。 方法一：逐位判断
由于要求给定无符号整数的二进制 1 的个数，这里可以直接对 2 取模，拿到当前整数 n 的二进制最右边的数字，判断是否为 1 ，然后将 n 右移 1 位 ，逐位判断即可。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-位运算" href=https://yuk1pedia.github.io/learning-notes/2024-10-22-bit-operation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-动态规划</h2></header><div class=entry-content><p>1.斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给定 n ，请计算 F(n) 。
答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2：
输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3：
输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-动态规划" href=https://yuk1pedia.github.io/learning-notes/2024-11-1-dynamic-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-栈和队列</h2></header><div class=entry-content><p>1.用两个栈实现队列 读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：
push(bookID)：把借阅的书籍还到图书馆。 pop()：从图书馆中借出书籍。 为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 最早 归还到图书馆的书籍。你需要返回 每次读者借出书的值 。
如果没有归还的书可以取出，返回 -1 。
示例 1：
输入： ["BookQueue", "push", "push", "pop"] [[], [1], [2], []] 输出：[null,null,null,1] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.pop(); // return 1, queue is [2] 提示：
1 &lt;= bookID &lt;= 10000 最多会对 push、pop 进行 10000 次调用 思路
用两个栈 st1 和 st2 实现队列，我们将 st2 作为辅助栈，其栈顶元素即为队首元素。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-栈和队列" href=https://yuk1pedia.github.io/learning-notes/2024-10-8-stack_and_queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>leetcode</h2></header><div class=entry-content><p>1.找出最具竞争力的子序列（单调栈+贪心） 给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。
数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。
在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。
示例 1：
输入：nums = [3,5,2,6], k = 2 输出：[2,6] 解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。 示例 2：
输入：nums = [2,4,3,3,5,4,9,6], k = 4 输出：[2,3,3,4] 提示：
1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^9 1 &lt;= k &lt;= nums.length 思路 根据题意，最具竞争力的子序列一定是较小的元素尽可能地放到序列的前面。所以我们可以遍历一遍数组，维持一个单调栈结构，将较小的元素尽可能地往前放。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to leetcode" href=https://yuk1pedia.github.io/learning-notes/2024-9-18-leetcode/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>leetcode hot100</h2></header><div class=entry-content><p>[TOC]
1.两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &lt;= nums.length &lt;= 10^4 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n^2) 的算法吗？
思路 **对于每一个遍历到的 x，我们只需要找到相应的 (target - x) 即可。**于是我们可以创建一个哈希表，只需要对 nums 数组进行一次遍历，每次遍历到 x，查询当前哈希表中是否存在 (target - x)，假设没有找到，那么将 x 插入到哈希表中，保证 x 不会与自己匹配。代码如下：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to leetcode hot100" href=https://yuk1pedia.github.io/learning-notes/2024-8-18-leetcode_hot100/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux常用命令</h2></header><div class=entry-content><p>1.文件与目录操作 命令 作用 使用场景 ls -lh 显示目录文件列表 查看文件大小、权限、修改时间等 cd 切换目录 进入代码目录、日志目录等 pwd 显示当前路径 确认当前工作目录 mkdir -p dir 创建目录 创建不存在的目录（含父级） rm -rf file 删除文件/目录 清理临时文件，删除无用日志 cp -r src dest 复制文件/目录 备份代码、配置文件等 mv src dest 移动/重命名文件 重命名日志、移动文件到目标目录 find /path -name "*.log" 查找文件 定位日志文件、查找大文件 du -sh file 查看文件大小 确定哪些文件占用空间过大 df -h 查看磁盘使用情况 确保服务器磁盘空间足够 2.进程管理 命令 作用 使用场景 ps aux 查看所有进程 查找某个进程的 PID top / htop 实时查看 CPU/内存使用 排查服务器性能问题 kill -9 PID 强制结束进程 终止卡死的程序 pkill -f process_name 根据名称杀进程 结束 Web 服务器进程 nohup command & 后台运行进程 运行服务后保持终端关闭 jobs / fg / bg 管理后台进程 让任务在后台执行 3.网络调试 命令 作用 使用场景 ifconfig / ip a 查看 IP 地址 确认服务器 IP ping google.com 测试网络连通性 检查网络是否可用 curl -I http://example.com 发送 HTTP 请求 检测 API 是否正常 wget url 下载文件 获取远程资源 netstat -tulnp / ss -tulnp 查看监听端口 确保服务正确运行 telnet IP PORT 测试端口连通性 确认服务是否开放端口 scp file user@remote:/path 远程传输文件 部署代码到远程服务器 rsync -avz src dest 高效同步文件 备份数据，服务器同步代码 4.日志管理 命令 作用 使用场景 cat file.log 显示完整日志 查看小型日志文件 less file.log 分页查看 适用于大日志文件 tail -f file.log 实时查看日志 监控应用运行状态 grep "error" file.log 过滤关键字 查找日志错误信息 awk '{print $1}' file.log 处理文本 提取指定字段 sed -i 's/old/new/g' file.log 替换文本 修改日志或配置文件</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to Linux常用命令" href=https://yuk1pedia.github.io/learning-notes/2025-3-10-common-linux-commands/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MyBatis-plus</h2></header><div class=entry-content><p>简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具包，它在 MyBatis 的基础上进行了一些优化和提升，旨在简化开发，提高开发效率，减少冗余代码
提升与特性 1.无侵入式增强 MyBatis-Plus 是在 MyBatis 基础上的增强，不需要修改现有 MyBatis 的配置和代码，最大程度地保持兼容性和灵活性。
2.增强的 CRUD 操作 MyBatis-Plus 提供了内置的通用 Mapper 和 Service，开发者不再需要编写常见的增删改查（CRUD）方法。通过继承 BaseMapper 接口，开发者可以直接调用现成的方法来进行数据库操作。
常见的 CRUD 方法：
insert() updateById() selectById() deleteById() selectList() selectOne() selectCount() 举个例子：
假设有一个 User 实体类，包含用户信息的字段。
@Data public class User { private Long id; private String name; private Integer age; private String email; } Mapper 接口：MyBatis-Plus 提供了 BaseMapper 接口，只需让自己的 Mapper 接口继承 BaseMapper，就能自动拥有常用的 CRUD 方法。
public interface UserMapper extends BaseMapper&lt;User> { // 你可以根据需要添加自定义的方法 } 插入操作： @Autowired private UserMapper userMapper; public void insertUser() { User user = new User(); user.setName("John"); user.setAge(30); user.setEmail("john.doe@example.com"); // 插入用户 userMapper.insert(user); } 注意： 插入时会自动返回 user 的主键值，如果数据库使用的是自增主键。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to MyBatis-plus" href=https://yuk1pedia.github.io/learning-notes/2024-11-19-mybatis-plus/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://yuk1pedia.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://yuk1pedia.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://yuk1pedia.github.io/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>