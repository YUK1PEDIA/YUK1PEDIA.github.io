<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>YUKIPEDIA's blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://yuk1pedia.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yuk1pedia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuk1pedia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuk1pedia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yuk1pedia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yuk1pedia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yuk1pedia.github.io/index.xml><link rel=alternate hreflang=en href=https://yuk1pedia.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yuk1pedia.github.io/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="YUKIPEDIA's blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="YUKIPEDIA's blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"YUKIPEDIA's blog","url":"https://yuk1pedia.github.io/","description":"","logo":"https://yuk1pedia.github.io/favicon.ico","sameAs":["https://github.com/YUK1PEDIA"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuk1pedia.github.io/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuk1pedia.github.io/learning-notes title="Learning Notes"><span>Learning Notes</span></a></li><li><a href=https://yuk1pedia.github.io/algorithm title=Algorithm><span>Algorithm</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JavaWeb学习笔记</h2></header><div class=entry-content><p>web前端 1.Web标准 Web标准也称为网页标准，由一系列的标准组成 三个组成部分： HTML：负责网页的结构（页面元素和内容） CSS：负责网页的表现（页面元素的外观、位置等页面样式，如颜色、大小等） JavaScript：负责网页的行为（交互效果） 2.HTML、CSS 什么是HTML、CSS？
HTML（HyperText Markup Language）：超文本标记语言 超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容 标记语言：由标签构成的语言 HTML标签都是预定义好的。例如：使用展示超链接，使用展示图片，展示视频 HTML代码直接在浏览器中运行，HTML标签由浏览器解析 CSS（Cascading Style Sheet）：层叠样式表，用于控制页面的样式 案例：HTML快速入门
新建文本文件，后缀名改为.html 编写HTML结构标签 在中填写内容 小结
HTML结构标签 &lt;html> &lt;head> &lt;title>HTML&lt;/title> &lt;/head> &lt;body> &lt;/body> &lt;/html> 特点 HTML标签不区分大小写 HTML标签属性值单双引号都可以 HTML语法松散 基础标签&样式
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to JavaWeb学习笔记" href=https://yuk1pedia.github.io/posts/learning-notes/2024-8-16-javaweb/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Java的反射机制</h2></header><div class=entry-content><p>1.什么是反射机制？ 反射（Reflection）是Java中的一个强大功能，允许程序在运行时动态地访问和操作类的元数据（如类名、字段、方法等）。通过反射，Java程序可以在运行时动态地获取类的信息，甚至动态地创建对象和调用方法。
举个简单的例子，在编写程序时，通常是明确地知道类的名字和结构，然后直接使用它们。反射则允许你在运行时才知道类的信息，并通过这些信息去操作类。所以说，反射的作用就是获取类的信息（成员变量、方法、构造方法等）
2.反射机制的工作原理 反射的核心就是通过类的字节码来动态获取类的元数据，并在运行时操作这些信息。反射依赖于Java类加载机制，类的字节码通过类加载器加载到内存中后，反射机制就能操作它们。
2.1 反射的基本流程 类加载：
在Java程序中，类并不是在编译时就加载到内存的，而是当JVM第一次需要使用该类时，它才会加载这个类（如创建实例、调用方法时）。
反射通过Class.forName()等方法动态加载类，并获得该类的Class对象。
获取类的元数据：
通过反射，你可以获取类的构造方法、字段、方法等元数据。这个过程是通过Class对象来实现的。 比如，使用clazz.getDeclaredMethods()可以获取类的所有方法，clazz.getDeclaredFields()可以获取类的所有字段。 动态创建对象和调用方法：
使用反射，你不仅能获取类的信息，还能动态地创建对象、调用方法、修改字段等。通过Method.invoke()可以动态调用类的方法，通过Constructor.newInstance()可以创建类的实例。 2.2 核心类和方法 Class：Class类是反射的核心，它代表了一个类的字节码。通过Class对象，你可以动态获取该类的构造方法、字段、方法等信息。
示例：
Class&lt;?> clazz = Class.forName("java.lang.String"); Field、Method、Constructor：这些类提供了反射操作字段、方法、构造函数的接口。通过这些接口，你可以动态地获取类的成员变量、方法信息，甚至修改它们的值。
3.反射的应用场景 3.1 框架和库开发 许多Java框架（如Spring、Hibernate）都依赖反射机制来实现动态注入、配置和对象创建。反射让框架能够在运行时发现并操作类，而不需要提前在源代码中硬编码。 依赖注入（Dependency Injection）：Spring框架通过反射来扫描类和字段，自动将依赖的对象注入到目标类中。 AOP（面向切面编程）：Spring AOP使用反射来动态地创建代理对象，并在方法调用前后插入切面逻辑。 3.2 动态代理 反射常用于实现动态代理。动态代理允许你在运行时动态生成一个实现了指定接口的类，并在调用方法时插入自定义逻辑。
例如，Java的Proxy类配合反射可以创建一个代理对象，代理对象会将方法调用转发给一个处理器。
MyInterface proxy = (MyInterface) Proxy.newProxyInstance( MyInterface.class.getClassLoader(), new Class[]{MyInterface.class}, new MyInvocationHandler()); 3.3 插件系统和模块化应用 在一些需要插件化或者模块化的系统中，反射非常有用。通过反射，程序可以在运行时动态加载并使用外部插件或模块，而无需提前知道它们的具体实现。
比如，一个插件系统可能在启动时扫描特定的插件目录，通过反射加载插件类并执行它们。
3.4 JDBC数据库操作 **JDBC（Java数据库连接）**使用反射来动态加载数据库驱动类。例如，Class.forName("com.mysql.cj.jdbc.Driver")通过反射加载数据库驱动类，并注册它，使得数据库操作可以在运行时进行。 3.5 单元测试和框架调试 在单元测试中，反射用于访问和测试私有方法或字段，这对于测试框架尤其重要。比如，JUnit在进行测试时，可能需要通过反射来调用私有方法或检查私有字段的值。 4.反射的优缺点 4.1 优点 灵活性：反射可以让程序在运行时决定要执行哪些操作，这使得程序具有高度的灵活性。 解耦：通过反射，框架可以在运行时动态地发现和调用类的方法，而不需要在编译时明确指定，从而提高了系统的解耦性。 动态性：反射支持在运行时加载类、创建对象、调用方法，这使得程序能够更适应变化的需求。 4.2 缺点 性能开销：反射是基于动态查找和解析的，因此它比直接调用方法或访问字段要慢一些。过度使用反射可能会导致性能问题。 类型安全问题：反射是动态操作的，编译时无法检查代码的正确性，容易引发类型转换等错误。使用反射时需要特别小心。 代码可读性差：反射使得代码的执行过程变得不透明，难以理解和调试。反射的代码通常不如直接调用的代码直观。 5.反射的常见操作 加载类 Class&lt;?> clazz = Class.forName("com.example.MyClass"); 获取类的构造方法 Constructor&lt;?> constructor = clazz.getConstructor(String.class, int.class); Object obj = constructor.newInstance("John", 30); 获取类的方法 Method method = clazz.getDeclaredMethod("sayHello"); method.setAccessible(true); // 如果方法是私有的 method.invoke(obj); 获取类的字段 Field field = clazz.getDeclaredField("name"); field.setAccessible(true); // 如果字段是私有的 String name = (String) field.get(obj);</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to Java的反射机制" href=https://yuk1pedia.github.io/posts/learning-notes/2024-11-27-java_reflection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lambda表达式在STL中的应用</h2></header><div class=entry-content><p>C++中的Lambda表达式是一种简洁的方式来定义匿名函数，尤其在需要传递函数作为参数或局部定义函数时非常方便
Lambda表达式的语法格式如下：
[capture](parameters) -> return_type { // function body }; capture：用于捕获外部变量，类似闭包。可以通过值传递或引用传递。 parameters：函数的参数列表（可以为空）。 return_type（可选）：指定返回类型，若省略，编译器会自动推导。 function body：函数体，包含实际执行的代码。 举个简单的例子：
auto add = [](int a, int b) -> int { return a + b; }; 这个Lambda表达式创建了一个匿名函数，它接受两个整数参数a和b，并返回它们的和。
捕获外部变量：在Lambda表达式中可以通过捕获列表来引用函数外部的变量，有三种常见方式：
按值捕获 [x]：捕获外部变量x的值。
按引用捕获 [&amp;x]：捕获外部变量x的引用，可以在Lambda内部修改它。
隐式捕获 [=]（按值捕获所有外部变量）、[&]（按引用捕获所有外部变量）。
示例：
int factor = 10; auto multiply = [factor](int x) { return x * factor; }; // 按值捕获 常见用法
自定义比较器：在排序、优先队列等场合，通常需要根据特定规则对元素进行排序。
std::sort 自定义排序： vector&lt;int> arr = {5, 2, 9, 1}; sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; // 降序排列 }); 优先队列（最大堆或最小堆）： priority_queue&lt;int, vector&lt;int>, decltype([](int a, int b) { return a > b; })> pq; 函数对象作为参数传递：在STL算法函数中，Lambda常被用作传递的回调函数，比如std::for_each, std::count_if等。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to Lambda表达式在STL中的应用" href=https://yuk1pedia.github.io/posts/learning-notes/2024-9-13-lambda/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-二叉树</h2></header><div class=entry-content><p>1.根据前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
示例 1:
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2:
输入: preorder = [-1], inorder = [-1] 输出: [-1] 提示:
1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 思路
前序遍历：按照「根-左子树-右子树」的顺序遍历二叉树。
中序遍历：按照「左子树-根-右子树」的顺序遍历二叉树。
我们来看看示例 1 是怎么生成这棵二叉树的。
递归边界：如果 preorder 的长度是 0，对应着空节点，返回空。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-二叉树" href=https://yuk1pedia.github.io/posts/learning-notes/2024-10-21-binary-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-位运算</h2></header><div class=entry-content><p>1.位1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示：
输入必须是长度为 32 的 二进制串 。 方法一：逐位判断
由于要求给定无符号整数的二进制 1 的个数，这里可以直接对 2 取模，拿到当前整数 n 的二进制最右边的数字，判断是否为 1 ，然后将 n 右移 1 位 ，逐位判断即可。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-位运算" href=https://yuk1pedia.github.io/posts/learning-notes/2024-10-22-bit-operation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-动态规划</h2></header><div class=entry-content><p>1.斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给定 n ，请计算 F(n) 。
答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2：
输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3：
输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-动态规划" href=https://yuk1pedia.github.io/posts/learning-notes/2024-11-1-dynamic-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LCR-栈和队列</h2></header><div class=entry-content><p>1.用两个栈实现队列 读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：
push(bookID)：把借阅的书籍还到图书馆。 pop()：从图书馆中借出书籍。 为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 最早 归还到图书馆的书籍。你需要返回 每次读者借出书的值 。
如果没有归还的书可以取出，返回 -1 。
示例 1：
输入： ["BookQueue", "push", "push", "pop"] [[], [1], [2], []] 输出：[null,null,null,1] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.pop(); // return 1, queue is [2] 提示：
1 &lt;= bookID &lt;= 10000 最多会对 push、pop 进行 10000 次调用 思路
用两个栈 st1 和 st2 实现队列，我们将 st2 作为辅助栈，其栈顶元素即为队首元素。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to LCR-栈和队列" href=https://yuk1pedia.github.io/posts/learning-notes/2024-10-8-stack_and_queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>leetcode</h2></header><div class=entry-content><p>1.找出最具竞争力的子序列（单调栈+贪心） 给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。
数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。
在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。
示例 1：
输入：nums = [3,5,2,6], k = 2 输出：[2,6] 解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。 示例 2：
输入：nums = [2,4,3,3,5,4,9,6], k = 4 输出：[2,3,3,4] 提示：
1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^9 1 &lt;= k &lt;= nums.length 思路 根据题意，最具竞争力的子序列一定是较小的元素尽可能地放到序列的前面。所以我们可以遍历一遍数组，维持一个单调栈结构，将较小的元素尽可能地往前放。
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to leetcode" href=https://yuk1pedia.github.io/posts/learning-notes/2024-9-18-leetcode/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>leetcode hot100</h2></header><div class=entry-content><p>[TOC]
1.两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &lt;= nums.length &lt;= 10^4 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n^2) 的算法吗？
思路 **对于每一个遍历到的 x，我们只需要找到相应的 (target - x) 即可。**于是我们可以创建一个哈希表，只需要对 nums 数组进行一次遍历，每次遍历到 x，查询当前哈希表中是否存在 (target - x)，假设没有找到，那么将 x 插入到哈希表中，保证 x 不会与自己匹配。代码如下：
...</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to leetcode hot100" href=https://yuk1pedia.github.io/posts/learning-notes/2024-8-18-leetcode_hot100/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux常用命令</h2></header><div class=entry-content><p>1.文件与目录操作 命令 作用 使用场景 ls -lh 显示目录文件列表 查看文件大小、权限、修改时间等 cd 切换目录 进入代码目录、日志目录等 pwd 显示当前路径 确认当前工作目录 mkdir -p dir 创建目录 创建不存在的目录（含父级） rm -rf file 删除文件/目录 清理临时文件，删除无用日志 cp -r src dest 复制文件/目录 备份代码、配置文件等 mv src dest 移动/重命名文件 重命名日志、移动文件到目标目录 find /path -name "*.log" 查找文件 定位日志文件、查找大文件 du -sh file 查看文件大小 确定哪些文件占用空间过大 df -h 查看磁盘使用情况 确保服务器磁盘空间足够 2.进程管理 命令 作用 使用场景 ps aux 查看所有进程 查找某个进程的 PID top / htop 实时查看 CPU/内存使用 排查服务器性能问题 kill -9 PID 强制结束进程 终止卡死的程序 pkill -f process_name 根据名称杀进程 结束 Web 服务器进程 nohup command & 后台运行进程 运行服务后保持终端关闭 jobs / fg / bg 管理后台进程 让任务在后台执行 3.网络调试 命令 作用 使用场景 ifconfig / ip a 查看 IP 地址 确认服务器 IP ping google.com 测试网络连通性 检查网络是否可用 curl -I http://example.com 发送 HTTP 请求 检测 API 是否正常 wget url 下载文件 获取远程资源 netstat -tulnp / ss -tulnp 查看监听端口 确保服务正确运行 telnet IP PORT 测试端口连通性 确认服务是否开放端口 scp file user@remote:/path 远程传输文件 部署代码到远程服务器 rsync -avz src dest 高效同步文件 备份数据，服务器同步代码 4.日志管理 命令 作用 使用场景 cat file.log 显示完整日志 查看小型日志文件 less file.log 分页查看 适用于大日志文件 tail -f file.log 实时查看日志 监控应用运行状态 grep "error" file.log 过滤关键字 查找日志错误信息 awk '{print $1}' file.log 处理文本 提取指定字段 sed -i 's/old/new/g' file.log 替换文本 修改日志或配置文件</p></div><footer class=entry-footer></footer><a class=entry-link aria-label="post link to Linux常用命令" href=https://yuk1pedia.github.io/posts/learning-notes/2025-3-10-common-linux-commands/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://yuk1pedia.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://yuk1pedia.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://yuk1pedia.github.io/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>