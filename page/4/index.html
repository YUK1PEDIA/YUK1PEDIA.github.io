<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.147.8"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>YUKIPEDIA&#39;s blog</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://yuk1pedia.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yuk1pedia.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yuk1pedia.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yuk1pedia.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yuk1pedia.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yuk1pedia.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://yuk1pedia.github.io/index.xml">
<link rel="alternate" hreflang="en" href="https://yuk1pedia.github.io/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://yuk1pedia.github.io/">
  <meta property="og:site_name" content="YUKIPEDIA&#39;s blog">
  <meta property="og:title" content="YUKIPEDIA&#39;s blog">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YUKIPEDIA&#39;s blog">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "YUKIPEDIA's blog",
  "url": "https://yuk1pedia.github.io/",
  "description": "",
  "logo": "https://yuk1pedia.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yuk1pedia.github.io/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yuk1pedia.github.io/learning-notes" title="Learning Notes">
                    <span>Learning Notes</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring Task
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是 Spring Task Spring Task 是 Spring 框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑，是一个定时任务框架。
应用场景：
信用卡每月还款提醒 银行贷款每月还款提醒 火车票售票系统处理未支付订单 ……
cron 表达式 通过 cron 表达式可以定义任务触发的事件
构成规则：分为 6 或 7 个域，由空格分割开，每个域代表一个含义
每个域的含义分别为：秒、分钟、小时、日、月、周、年（可选）。需要注意的是，周和日两者只能填一个，周代表是周几，日代表是这个月的多少号。
秒 分钟 小时 日 月 周 年 0 0 9 12 10 ? 2024 2024年10月12日上午9点整对应的 cron 表达式为：0 0 9 12 10 ? 2024
实际上 cron 表达式不需要我们去手写，可以使用在线生成器生成：在线Cron表达式生成器 (qqe2.com)
Spring Task 使用步骤 导入 maven 坐标 spring-context 启动类添加注解 @EnableScheduling 开启任务调度 package com.sky; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.transaction.annotation.EnableTransactionManagement; @SpringBootApplication @EnableTransactionManagement //开启注解方式的事务管理 @Slf4j @EnableCaching // 开启缓存注解 @EnableScheduling // 开启任务调度 public class SkyApplication { public static void main(String[] args) { SpringApplication.run(SkyApplication.class, args); log.info(&#34;server started&#34;); } } 自定义定时任务类 package com.sky.task; import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; import java.util.Date; /** * 自定义定时任务类 */ @Component @Slf4j public class MyTask { /** * 定时任务，每隔五秒触发一次 */ @Scheduled(cron = &#34;0/5 * * * * ?&#34;) public void executeTask() { log.info(&#34;定时任务开始执行：{}&#34;, new Date()); } } </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Spring Task" href="https://yuk1pedia.github.io/learning-notes/2024-10-3-spring_task/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Springboot框架学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>SpringBoot概念与功能 概念
SpringBoot提供一种快速使用Spring的方式 基于约定优于配置的思想 不必在配置与逻辑业务之间进行思维切换，全身心投入到逻辑业务的代码编写 功能
自动配置：SpringBoot的自动配置是一个运行时（准确来说是程序启动时）的过程，这些过程均由SpringBoot自动完成
起步依赖：将具备某种功能的坐标打包到一起，并提供一些默认的功能
辅助功能：提供一些大型项目中的非功能性特性，如嵌入式服务器、安全、指标等
SpringBoot配置 配置文件分类 SpringBoot是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置的话，可以使用**application.properties或者application.yml(application.yaml)**进行配置
properties server.port=8080 yml server port: 8080 SpringBoot提供了2种配置文件类型：properties和yml/yaml 默认配置文件名称：application 在同一级目录下优先级为：properties &gt; yml &gt; yaml yaml文件 yaml全称是YAML Ain’t Markup Language。yaml是一种直观的能被电脑识别的数据序列化格式，并容易理解阅读。
yaml基本语法
大小写敏感 数据值前必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（不同操作系统Tab对应的空格数可能不同，导致层级混乱） 所进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 server port: 8080 address: 127.0.0.1 name: abc yaml数据格式
对象(map)：键值对的集合 person: name: zhangsan # 行内写法 person: {name: zhangsan} 数组：一组按次序排列的值 address: - beijing - shanghai # 行内写法 address: [beijing,shanghai] 纯量：单个的、不可再分的值（可理解为常量） msg1: &#39;hello \n world&#39; # 单引号忽略转义字符 msg2: &#34;hello \n world&#34; # 双引号识别转义字符 参数引用 name: lisi person: name: ${name} # 引用上面定义的name的值 读取配置文件内容 @Value @Value(&#34;${name}&#34;) private String name; @Value(&#34;${person.name}&#34;) private String name2; Environment @Autowired private Environment env; System.out.println(env.getProperty(&#34;person.name&#34;)); System.out.println(env.getProperty(&#34;address[0]&#34;)); @ConfigurationProperties 创建对象与yml配置文件的内容进行绑定
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Springboot框架学习笔记" href="https://yuk1pedia.github.io/learning-notes/2024-5-13-springboot/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring框架学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>IoC(Inversion of Control) 控制反转与DI(Dependency Injection)依赖注入 IoC(Inversion of Control) 控制反转
使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转（降低程序的耦合度） Spring技术对IoC思想进行了实现
Spring提供了一个容器，称为IoC容器，用来充当思想中的“外部”
IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中被称为Bean
DI(Dependency Injection) 依赖注入
在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 以上操作的目标：充分解耦
bean相关 bean配置 bean基础配置
id：bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一
class：bean的类型，即配置的bean的全路径类名
例子
&lt;bean id=&#34;bookDao&#34; class=&#34;com.itheima.dao.impl.BookDaoImpl&#34;/&gt; &lt;bean id=&#34;bookService&#34; class=&#34;com.itheima.service.impl.BookServiceImpl&#34;&gt; bean的别名 name：为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔 例子 &lt;bean id=&#34;bookService&#34; name=&#34;service service4 bookEbi&#34; class=&#34;com.itheima.service.impl.BookServiceImpl&#34;&gt; &lt;property name=&#34;bookDao&#34; ref=&#34;bookDao&#34;/&gt; &lt;/bean&gt; bean的作用范围 scope：为bean设置作用范围，可选值为单例singleton，非单例prototype，若不写scope，则默认是单例对象 例子 &lt;bean id=&#34;bookDao&#34; name=&#34;dao&#34; class=&#34;com.itheima.dao.impl.BookDaoImpl&#34; scope=&#34;prototype&#34;/&gt; bean实例化 使用FactoryBean的方式实例化bean对象
实现FactoryBean接口，指定创建的泛型对象 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class&lt;?&gt; getObjectType() { return UserDao.class; } // 控制创建的bean是单例的还是非单例的，通常都是单例的 public boolean isSingleton() { return true; } } 配置 &lt;!--方式四：使用FactoryBean实例化bean--&gt; &lt;!--注意，这种构造方法创建的不是FactoryBean对象，而是FactoryBean对象中的getObject对象--&gt; &lt;bean id=&#34;userDao&#34; class=&#34;com.itheima.factory.UserDaoFactoryBean&#34;/&gt; bean的生命周期 初始化容器
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Spring框架学习笔记" href="https://yuk1pedia.github.io/learning-notes/2024-5-5-spring/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">STL容器——string成员函数
    </h2>
  </header>
  <div class="entry-content">
    <p>转载，原文链接：https://www.cnblogs.com/lynx-peng/p/16552710.html
1.构造与析构 构造
string()//构造空字符串 string(const char* s);//拷贝s所指向的字符串序列 string(const char* s, size_t n);//拷贝s所指向的字符串序列的第n个到结尾的字符 string(size_t n, char c);//将字符c复制n次 string(const string&amp; str);//拷贝构造函数 string(const string&amp; str, size_t pos, size_t len = npos);//拷贝s中从pos位置起的len个字符，若npos&gt;字符串长度，就拷贝到字符串结尾结束 析构
~string();//删除字符串 2.迭代器 /*迭代器*/ iterator begin(); //返回指向字符串第一个字符的迭代器 iterator end(); //返回指向字符串最后一个字符的下一个位置的迭代器 reverse_iterator rbegin(); //返回字符串最后一个字符的反向迭代器 reverse_iterator rend(); //返回指向字符串第一个字符之前的反向迭代器 /*常量迭代器*/ iterator cbegin(); //返回指向字符串第一个字符的迭代器 iterator cend(); //返回指向字符串最后一个字符的下一个位置的迭代器 reverse_iterator rcbegin(); //返回字符串最后一个字符的反向迭代器 reverse_iterator rcend(); //返回指向字符串第一个字符之前的反向迭代器 注：迭代器（非常量迭代器）和常量迭代器的区别如下：
非常量迭代器允许修改迭代器所指向的元素，这类迭代器通常用于需要修改容器中元素的情况 常量迭代器不允许修改迭代器所指向的元素，这类迭代器通常用于只需要读取容器中元素的情况 3.访问 reference at(size_type pos);//同char&amp; operator[]，返回pos位置字符的引用，字符串可读可写 char&amp; back();//返回最后字符的引用 char&amp; front();//返回第一个字符的引用 4.长度及容量 size_t size();//返回字符串字符个数 size_t length();//返回字符串字符个数 size_t max_size();//返回string对象中可存放的最大字符串的长度 size_t capacity();//返回string分配的存储容量。 void resize (size_t n);//调整源字符串的长度为n。 void resize (size_t n, char c);//调整字符串长度为n，并用字符c填充不足的部分 void reserve (size_t n = 0);//重新给源字符串分配存储最小为n的容量 void shrink_to_fit()//清理内存，使字符串的容量变得等于字符串的大小 void clear();//将字符串的内容清空，让源字符串成为一个空字符串（长度为0个字符） bool empty();//判断字符串是否为空 5.修饰 5.1.append() 在结尾添加字符串 string &amp; append(const string &amp; str)//在结尾添加一个string字符串 string &amp; append(const string &amp; str, size_type subpos, size_type sublen)//追加str中从subpos开始的sublen个字符(子串) string &amp; append(const charT * s)//C语言字符串 string &amp; append(const charT * s, size_type n)//C语言字符串(长度为n的子串) string &amp; append(size_type n, charT c)//n个字符c string &amp; append(InputIterator first, InputIterator last)//使用迭代器append 5.2.push_back() 将字符串添加到串尾 void push_back (charT c);//将字符C添加到结尾 5.3.assign() 赋值 string &amp;assign(const char *s);///char*类型的字符串赋给当前字符串 string &amp;assign(const char *s,int n);//从给定的 C 风格字符串 s 的前 n 个字符创建一个新的字符串，并将当前字符串设置为这个新字符串的内容 string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串 string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串 string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串 string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串 5.4.insert() 在串中间插入 string &amp; insert(size_type pos, const string &amp; str)//在pos位置插入字符串str string &amp; insert(size_type pos, const string &amp; str,size_type subpos, size_type sublen)//从subpos开始的sublen的子串 string &amp; insert(size_type pos, const charT * s)//C语言字符串 string &amp; insert(size_type pos, const charT * s, size_type n)//C语言字符串(长度为n的子串) string &amp; insert(size_type pos, size_type n, charT c)//n个字符c iterator insert(const_iterator p, size_type n, charT c)//使用迭代器索引插入n和字符 iterator insert(const_iterator p, charT c)//单一字符 iterator insert(iterator p, InputIterator first, InputIterator last)//使用迭代器insert 5.5.erase() 删除字符串中的特定字符 string &amp; erase(size_type pos=0, size_type len=npos)//从pos处删除len长度的字符 iterator erase(const_iterator p)//删除迭代器所指的单一字符 iterator erase(const_iterator first, const_iterator last)//删除2迭代器中间的字符 5.6.replace() 替换字符串的一部分 string &amp; replace(size_type pos,size_type len,const string &amp; str)//从pos位置开始，长度为len的字符替换为str string &amp; replace(const_iterator i1, const_iterator i2, const string &amp; str)//替换两迭代器之间的字符 string &amp; replace(size_type pos, size_type len, const string &amp; str,size_type subpos, size_type sublen)//使用子串替换 string &amp; replace(size_type pos, size_type len, const charT * s)//使用C语言字符串 string &amp; replace(const_iterator i1, const_iterator i2, const charT * s)//迭代器方法 string &amp; replace(size_type pos, size_type len, const charT * s, size_type n)//使用子串 string &amp; replace(const_iterator i1, const_iterator i2, const charT * s, size_type n)//迭代器方法 string &amp; replace(size_type pos, size_type len, size_type n, charT c)//用n个字符c替换 string &amp; replace(const_iterator i1, const_iterator i2, size_type n, charT c)//迭代器方法 string &amp; replace(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last)//迭代器方法 5.7.swap() 交换两字符串 void swap (&amp; str);//交换self和str 5.8.pop_back() 删除最后一个字符 void pop_back();//删除串中最后一个字符 6.操作 6.1.find() 查找 size_type find(const string &amp; str, size_type pos=0) const;//从母字符串的pos位置查找字串str.存在返回字串第一个字符的位置，不存在返回npos size_type find(const charT * s, size_type pos=0) const;//C语言字符串作为子串 size_type find(const charT * s, size_type pos, size_type n) const;//C语言字符串的子串(长度为n)作为被查找子串 size_type find(charT c, size_type pos=0) const;//查找单个字符 //倒着找 size_type rfind(const string &amp; str, size_type pos=npos) const; size_type rfind(const charT * s, size_type pos=npos); size_type rfind(const charT * s, size_type pos, size_type n); size_type rfind(charT c, size_type pos=npos) const; //查找字符串中与目标字符(串中任一个字符)相同的第一个字符 size_type find_first_of(const string &amp; str, size_type pos=0) const; size_type find_first_of(const charT * s, size_type pos=0) const; size_type find_first_of(const charT * s, size_type pos, size_type n); size_type find_first_of(charT c, size_type pos=0) const; //倒着找 or 找最后一个 size_type find_last_of(const string &amp; str, size_type pos=npos) const size_type find_last_of(const charT * s, size_type pos=npos) const size_type find_last_of(const charT * s, size_type pos, size_type n) const size_type find_last_of(charT c, size_type pos=npos) const //查找字符串中与目标字符(串中任一个字符)不相同的第一个字符 size_type find_first_not_of(const string &amp; str, size_type pos=0) const; size_type find_first_not_of(const charT * s, size_type pos=0) const; size_type find_first_not_of(const charT * s, size_type pos, size_type n) const; size_type find_first_not_of(charT c, size_type pos=0) const; //倒着找 or 找最后一个 size_type find_last_not_of(const string &amp; str, size_type pos=npos) const ; size_type find_last_not_of(const charT * s, size_type pos=npos) const; size_type find_last_not_of(const charT * s, size_type pos, size_type n) const; size_type find_last_not_of(charT c, size_type pos=npos) const ; 6.2.substr() 子串 string substr (size_type pos = 0, size_type len = npos) const;//返回一个从pos开始，len长度的string类型的子串 6.3.compare() 比较 int compare (const string&amp; str) const ;//比较字符串大小，源串大于str返回值&gt;0，相同=0,小于&lt;0 int compare (size_type pos, size_type len, const string&amp; str) const;//用自身的子串比较 int compare (size_type pos, size_type len, const string&amp; str, size_type subpos, size_type sublen) const;//两字符串均为子串 int compare (const charT* s) const;//C语言字符串 int compare (size_type pos, size_type len, const charT* s) const;//C语言字符串子串 int compare (size_type pos, size_type len, const charT* s, size_type n) const;//双子串 6.4.copy() 复制到字符数组 size_type copy (charT* s, size_type len, size_type pos = 0) const;//从string类型对象中至多复制n个字符到字符指针p指向的空间中。不添加&#39;\0&#39; 7.符号重载 7.1.= 赋值 string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串 string &amp;operator=(const char* s);//char*类型的字符串赋给当前字符串 string &amp;operator=(char c);//单个字符赋给当前字符串 7.2.[] 访问 char&amp; operator[] (size_t pos);//返回pos处字符的引用 越界导致未定义行为 7.3.&#43;= 追加 string&amp; operator&#43;= (const string&amp; str);//在结尾加如str字符串，等效于append string&amp; operator&#43;= (const char* s);//C语言字符串 string&amp; operator&#43;= (char c);//单个字符 8.补充：cctype 字符处理库 C&#43;&#43;从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型在头文件cctype中定义，使用 #include &lt;cctype&gt; 引入
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to STL容器——string成员函数" href="https://yuk1pedia.github.io/learning-notes/2024-9-5-stl-container----string-member-function/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">TCP超时重传机制的底层原理
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是 TCP 的超时重传？ 我们先回顾一下 TCP 的三个特点：面向连接、可靠、基于字节流，那么 TCP 的可靠传输是如何实现的呢？超时重传机制就是保证 TCP 可靠传输的一种手段。
超时重传能确保数据在传输过程中，即使因为丢包、网络延迟或其他原因导致数据包没有成功到达接收方，依然能够重新发送，从而实现可靠的数据传输。通俗来讲，超时重传就是发送方在发送数据后，会等待接收方的确认（回传的 ACK 报文）。如果没有在规定的时间内收到确认，就会重新发送数据包。
注意：ACK 报文是不会重传的。
超时重传的基本原理 每次发送一个数据包时，发送方都会设置一个定时器，该定时器会在一定的时间内等待接收方的 ACK 确认。如果定时器超时之前收到了 ACK ，则说明数据包成功到达接收方，TCP 连接继续进行。如果定时器到期了仍然没有收到 ACK ，则认为数据包丢失或者未达到接收方，发送方就会重新发送该数据包，这就是超时重传机制的基本原理。
如果发送方一直没有收到 ACK 确认，就会继续重发报文。但是一直重发也不行，因此在 Linux 中有一个 TCP 参数控制重传次数：tcp_orphan_retries 。当发送方重传报文的次数超过 tcp_orphan_retries 后，就不再重传报文。
我们以 TCP 的四次挥手中第一次挥手为例，当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。
正常情况下，如果能及时收到服务端（被动关闭方）的 ACK ，则会很快变为 FIN_WAIT_2 状态。
如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。
当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还没能收到第二次挥手，那么直接进入到 close 状态。
定时器的工作原理 定时器是超时重传机制的核心，定时器的作用是等待接收方的确认，如果超时没有收到确认，就进行重传。
初始定时器设置：当发送方发送一个数据包时，它会设置一个定时器，并假设接收方在规定时间内收到并确认数据。这个规定时间通常是根据网络环境和 RTT（Round Trip Time，往返时间）来设定的。 往返时间 RTT：每次发送数据包时，TCP会估计网络的 RTT ，并根据 RTT 来动态调整定时器的超时时间。这个值越小，重传的等待时间越短，反之越长。 动态调整超时：TCP 使用 RTT的估算值 来设置定时器。当连接进行数据传输时，它会记录每次的往返时间 RTT ，并动态调整定时器的超时值。这个值叫做 RTO（Retransmission Timeout），即重传超时时间。RTO 会根据网络的实际延迟自动调节，以避免因过短或过长的超时时间导致过多不必要的重传或超时。 参考：https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to TCP超时重传机制的底层原理" href="https://yuk1pedia.github.io/learning-notes/2025-2-27-the-underlying-principle-of-tcp-timeout-retransmission/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">一致性哈希
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 什么是一致性哈希？ 一致性哈希是一种特殊的哈希算法，主要用于分布式系统中，用于将数据分配到多个节点上，保证数据在节点变动时能够尽可能少地重新分配，提高系统的稳定性和扩展性。
它的核心思想是通过将数据和节点映射到一个虚拟的环形空间（哈希环）中，根据数据的位置决定存储在哪个节点上。当节点发生增删时，尽量减少数据的迁移量。
2. 背景与问题 在分布式系统中，数据存储在多个服务器（节点）上，为了实现负载均衡，我们通常需要通过哈希算法将数据映射到不同的节点。例如：
传统的哈希分布：
假设有 4 个服务器节点（A, B, C, D），我们用简单的哈希算法将数据分配到这些节点上：
hash(data) % N N 是节点数，hash(data) 是数据的哈希值。 比如：hash(&#34;data1&#34;) % 4 = 2，data1 被分配到节点 C。 问题：当节点变动时
如果增加一个新节点（如 E，节点数变为 5），所有的数据都需要重新分配：
hash(data) % 5 这会导致几乎所有数据重新分布，迁移代价非常高。
3. 一致性哈希的核心思想 一致性哈希通过一个环形空间解决了传统哈希算法的上述问题。
3.1 哈希环 一致性哈希将整个哈希值范围（如 0 ~ 2^32-1）组织成一个环形结构。 节点（服务器）和数据都通过哈希算法映射到这个环上。 节点的哈希：hash(node) 数据的哈希：hash(data) 3.2 数据存储规则 一个数据被存储到环上顺时针方向第一个节点（或称“后继节点”）上。
比如，节点 A、B、C、D 在环上，数据 data1 映射到节点之间的位置，则：
hash(data1) → 找到顺时针方向最近的节点 如果 hash(data1) 位于节点 A 和节点 B 之间，则数据 data1 存储到节点 B。
3.3 动态增减节点 当有新节点加入或离开时，只需要迁移受影响范围内的少量数据。 例如： 如果节点 E 加入环，它负责环上从前继节点（如 D）到自身之间的数据。 其他节点的数据分布不会受到影响。 4. 虚拟节点 在实际应用中，由于节点的分布可能不均匀，容易导致数据倾斜问题（部分节点存储的数据量过大）。为了解决这个问题，引入了虚拟节点的概念。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 一致性哈希" href="https://yuk1pedia.github.io/learning-notes/2024-12-19-hash/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">云原生
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是云原生？ 云原生是一种构建和运行应用程序的方法，它利用云计算的优势，使应用程序能够更好地适应云环境的动态性、弹性和分布式特性。云原生技术体系包含容器、容器编排、微服务、服务网格、不可变基础设施等一系列技术和理念。
弹性伸缩：能够根据业务负载的变化自动调整资源，实现快速的扩缩容，以确保应用程序始终能够以最佳性能运行 高可用性：通过多副本、故障转移等机制，保证应用程序在部分组件出现故障时仍能正常运行，提供持续的服务 敏捷开发与部署：支持快速迭代和频繁部署，开发团队可以更高效地进行应用程序的开发、测试和上线 资源高效利用：容器化技术使得多个应用程序可以共享底层基础设施资源，提高资源的利用率，降低成本 云原生代表技术 容器 一般我们说的“容器”（LinuxContainer，LXC），都是 “Linux容器” 。开源解决方案供应商红帽官网给出的容器定义：Linux® 容器是与系统其他部分隔离开的一系列进程。运行这些进程所需的所有文件都由另一个镜像提供，这意味着从开发到测试再到生产的整个过程中，Linux 容器都具有可移植性和一致性。因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。
容器提供进程级的隔离，可以将操作系统管理的资源划分到相互隔离的组中，在相互隔离的组之间解决资源使用存在冲突的问题。比如 APP1 只能在 centOS 上运行，APP2 只能在 Ubuntu 上运行，而同一个操作系统同时运行 APP1 和 APP2 就产生冲突，容器技术则恰恰可以解决这类问题。
Docker Docker 项目通过容器镜像，直接将一个应用运行所需的完整环境，即：整个操作系统的文件系统也打包了进去。Docker 项目大大降低了容器技术的使用门槛，轻量级，可移植，虚拟化，语言无关，写了程序扔上去做成镜像可以随处部署和运行，开发、测试和生产环境彻底统一了，还能进行资源管控和虚拟化。
典型的 Docker 平台包括 Kubernetes、Openshift V3 等。一句话解释 Docker？
没有集装箱就没有全球化，Docker 就是 IT 世界里的集装箱。
Kubernetes 有了容器，就需要编排管理容器的生命周期，K8s 就是一个通用容器编排调度器，用于编排管理容器的生命周期。
一个 K8s 集群，主要包括两个部分：一个 Master 节点和一群 Node 节点。
Master（主节点）：控制 K8s 节点的机器，也是创建作业任务的地方 Node（节点）：这些机器在 K8s 主节点的控制下执行被分配的任务，一个 Node 可能会运行多个 Pod，Pod 中的容器共同协作来提供某种服务 Pod：K8s 中最小的可部署和可管理的计算单元，由一个或多个容器构成的集合，作为一个整体被部署到一个单一节点。同一个 Pod 中的容器共享 IP 地址、进程间通讯（IPC）、主机名以及其它资源。Pod 将底层容器的网络和存储抽象出来，使得集群内的容器迁移更为便捷 Replicationcontroller：控制一个 Pod 在集群上运行的实例数量，用于确保 Pod 的副本数量始终保持在指定的数量 Service：用来暴露 Pod 的一种抽象机制，可以把它想象成一个 “网关” 或者 “地址簿”。因为 Pod 可能会在不同的 Node 上被创建、销毁或者重新调度，它们的 IP 地址是动态变化的。而 Service 为 Pod 提供了一个固定的 IP 地址和 DNS 名称，其他应用程序可以通过这个固定的地址来访问 Pod 提供的服务，而不需要关心 Pod 具体在哪个节点上以及其 IP 地址的变化 Kubelet：这个守护进程运行在各个工作节点上，负责获取容器列表，保证被声明的容器已经启动并且正常运行 K8s 的出现与其说是从最初的容器编排解决方案开始，倒不如说是为了解决应用上云（即云原生应用）这个难题。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 云原生" href="https://yuk1pedia.github.io/learning-notes/2025-4-25-cloud-native/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">什么是强引用、软引用、弱引用和虚引用？
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 强引用（Strong Reference） 强引用是最普通的引用，比如 Object obj = new Object();。只要强引用存在，对象就不会被垃圾回收。
强引用特点：
绝不回收：只要强引用存在，即使内存不足（OOM），JVM 宁可抛出内存错误，也不回收对象。 常见场景：日常代码中的普通对象都是强引用。 2. 软引用（Soft References） 软引用通过 SoftReference 类实现，比如 SoftReference&lt;Object&gt; softRef = new SoftReference&lt;&gt;(obj); 。
软引用特点：
内存不足时回收：当 JVM 发现内存不足时，会回收软引用指向的对象。 适合做缓存：比如缓存图片，内存不足时自动清理，避免 OOM 。 // 创建一个软引用 SoftReference&lt;byte[]&gt; softRef = new SoftReference&lt;&gt;(new byte[1024 * 1024]); // 使用对象 byte[] data = softRef.get(); // 如果对象未被回收，可以拿到 3. 弱引用（Weak Reference） 弱引用通过 WeakReference 类实现，比如 WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(obj); 。
弱引用特点：
立即回收：和软引用类似，但软引用在发生垃圾回收时不一定会被回收（内存不足时软引用才被回收），而弱引用无论内存是否充足，只要发生垃圾回收，弱引用指向的对象都会被回收。 适合临时缓存：比如维护一种可有可无的缓存（如 ThreadLocal 中的 Entry 就是弱引用）。 WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object()); System.gc(); // 触发垃圾回收（非强制） System.out.println(weakRef.get()); // 可能输出 null 4. 虚引用（Phantom Reference） 虚引用通过 PhantomReference 类实现，必须配合引用队列使用。举个例子，虚引用就像在物品（对象）上安装了一个“销毁报警器”。当物品被销毁时（对象被垃圾回收），你会收到一个通知，但是你永远拿不到这个物品本身。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 什么是强引用、软引用、弱引用和虚引用？" href="https://yuk1pedia.github.io/learning-notes/2025-1-29-what-are-strong-references-soft-referencesweak-referencesand-virtual-references/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式相关：CAP和BASE
    </h2>
  </header>
  <div class="entry-content">
    <p>1.CAP 理论 CAP 原则又称为 CAP 定理，指的是在一个分布式系统中，Consistency（一致性） 、Availability（可用性） 、Partition tolerance（分区容错性） 这三个基本需求，最多只能同时满足其中的两个。
那么 CAP 分别是什么？
一致性（C）：数据在多个副本之间能够保持一致的特性 可用性（A）：系统提供的服务一直处于可用的状态，每次请求都能获得正确的响应 分区容错性（P）：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务 什么是分区？ 在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。
为什么 CAP 三者不可兼得？ 首先，在分布式系统中，分区是不可避免的，因此分区容错性（P）是一定要满足的。接下来再看看，在满足分区容错的基础上，能不能同时满足一致性（C）和可用性（A）。
假如现在有两个分区 N1 和 N2 ，N1 和 N2 分别有不同的分区存储 D1 和 D2 ，以及不同的服务 S1 和 S2 。
在满足**一致性（C）**时，N1 和 N2 的数据要求值一样，D1 = D2 在满足**可用性（A）**时，无论访问 N1 还是 N2 ，都能获取及时的响应 现在有这样的场景：
用户访问了 N1 ，修改了 D1 的数据 用户再次访问，但此时请求落在了 N2 ，此时 D1 和 D2 的数据不一致 接下来：
保证一致性（C）：此时 D1 和 D2 数据不一致，要保证一致性就不能返回不一致的数据，此时**可用性（A）**就无法保证 保证可用性（A）：立即响应，可用性得到了保证，但是此时相应的数据和 D1 不一致，此时**一致性（C）**就无法保证 可以看出，在满足**分区容错性（P）**的前提下，**一致性（C）和可用性（A）**是矛盾的
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分布式相关：CAP和BASE" href="https://yuk1pedia.github.io/learning-notes/2025-3-11-cap-vs-base/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式锁
    </h2>
  </header>
  <div class="entry-content">
    <p>基本原理和实现方式 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行。 那么分布式锁他应该满足的条件呢？ 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行 高可用：程序不易崩溃，时时刻刻都保证较高的可用性 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能 安全性：安全也是程序中必不可少的一环 常见的分布式锁有三种： Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见 Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁 Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，zookeeper中实现分布式锁主要依赖于它的临时节点（ephemeral node）和顺序节点（sequential node）特性。 Redis 分布式锁的实现核心思路 实现分布式锁时需要实现的两个基本方法：
获取锁： 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回 true，失败返回 false 释放锁： 手动释放 超时释放：获取锁时添加一个超时时间 实现核心思路：
我们利用 redis 的 setnx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个 key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可。
实现基于 redis 的分布式锁 分布式锁的基本接口
/** * 分布式锁 */ public interface ILock { /** * 尝试获取锁 * @param timeoutSec * @return */ boolean tryLock(long timeoutSec); /** * 释放锁 */ void unlock(); } 简单分布式锁的实现
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分布式锁" href="https://yuk1pedia.github.io/learning-notes/2024-11-9-distributed-lock/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://yuk1pedia.github.io/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://yuk1pedia.github.io/page/5/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://yuk1pedia.github.io/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
